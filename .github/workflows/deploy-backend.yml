name: Deploy Backend (ZIP + Publish Profile)

on:
  push:
    branches: [ main ]
    paths:
      - "server/**"
      - ".github/workflows/deploy-backend.yml"

permissions:
  contents: read

# Prevent parallel deploys that can cause 409/502 conflicts
concurrency:
  group: smarttask-ai-backend
  cancel-in-progress: true

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      # Checkout repository
      - uses: actions/checkout@v4

      # Use Node 20 and enable npm cache scoped to server
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: server/package-lock.json

      # Build backend: clean install -> tsc build -> prune dev deps -> verify dist entry
      - name: Build server
        working-directory: server
        run: |
          set -e
          npm ci
          npm run build
          npm ci --omit=dev
          test -f dist/index.js || (echo "dist/index.js missing" && exit 1)

      # Ensure 'cors' installed (force if missing)
      - name: Ensure 'cors' installed (force if missing)
        working-directory: server
        run: |
          if [ ! -f node_modules/cors/package.json ]; then
            echo "cors missing → installing..."
            npm i cors@^2.8.5 --no-save
          fi
          test -f node_modules/cors/package.json

      # Ensure runtime deps exist after --omit=dev (catch 'cors'/'express' missing early)
      - name: Verify runtime deps (express/cors)
        working-directory: server
        run: |
          echo "Checking runtime dependencies..."
          ls -la node_modules/cors || echo "WARNING: cors not found in node_modules"
          ls -la node_modules/express || echo "WARNING: express not found in node_modules"
          node -e "try{require('express');require('cors');console.log('OK runtime deps');}catch(e){console.error('Missing runtime dependency (move it from devDependencies to dependencies):', e?.message||e); process.exit(1);}"

      # Double-check that clerkRoutes.js exists in the emitted dist
      - name: Verify dist artifacts exist
        run: |
          ls -lah server/dist || true
          ls -lah server/dist/routes || true
          node -e "const fs=require('fs');process.exit(fs.existsSync('server/dist/routes/clerkRoutes.js')?0:(console.error('missing dist/routes/clerkRoutes.js'),1));"

      # Create a lean ZIP for Run-From-Package
      - name: Create ZIP package (tarball node_modules for Azure startup)
        run: |
          set -e
          cd server

          # Clean any Oryx markers (do NOT touch node_modules)
          rm -f oryx-manifest.toml .deployment
          echo "Removed Oryx artifacts, current directory contents:"
          ls -la

          # Sanity: cors must exist before tar
          echo "Verifying cors package exists in node_modules..."
          test -f node_modules/cors/package.json || { echo "ERROR: cors package missing before tar"; exit 1; }

          # Create tarball of node_modules
          echo "Creating node_modules.tar.gz..."
          tar -C node_modules -czf node_modules.tar.gz .

          # Verify inside the tarball (no pipe → no Broken pipe)
          echo "Verifying cors exists inside node_modules.tar.gz..."
          tar -tzf node_modules.tar.gz cors/package.json >/dev/null 2>&1 \
            || { echo "ERROR: cors not found inside node_modules.tar.gz"; exit 1; }

          # Add a tiny startup script that extracts node_modules if needed
          cat > startup.sh <<'SH'
          #!/usr/bin/env bash
          set -e
          cd "$(dirname "$0")"
          if [ ! -d "./node_modules" ] && [ -f "./node_modules.tar.gz" ]; then
            echo "[startup] Extracting node_modules.tar.gz..."
            tar -xzf node_modules.tar.gz -C .
          fi
          # Adjust the entrypoint if your app filename differs:
          node dist/index.js
          SH
          chmod +x startup.sh

          # Build deployment ZIP with dist + package.json + lock + tarball + startup
          zip -r ../backend-deployment.zip dist package.json package-lock.json node_modules.tar.gz startup.sh \
            -x "oryx-manifest.toml" ".deployment"

          cd ..
          ls -la backend-deployment.zip
          echo "ZIP size:" && du -h backend-deployment.zip

          # Verify the tarball is present in the ZIP (don't search for 'cors' here)
          echo "Verifying node_modules.tar.gz is present in the ZIP..."
          unzip -l backend-deployment.zip | grep -q "node_modules.tar.gz" \
            || { echo "ERROR: node_modules.tar.gz missing from ZIP"; exit 1; }

          # Deep-verify: check 'cors' inside the tarball embedded in the ZIP
          echo "Verifying cors exists inside the embedded tarball..."
          unzip -p backend-deployment.zip node_modules.tar.gz > /tmp/node_modules_embedded.tgz
          tar -tzf /tmp/node_modules_embedded.tgz cors/package.json >/dev/null 2>&1 \
            || { echo "ERROR: cors not found inside embedded node_modules.tar.gz"; exit 1; }
          rm -f /tmp/node_modules_embedded.tgz

          # Verify no Oryx artifacts in ZIP (ALLOW node_modules.tar.gz)
          echo "Verifying no Oryx artifacts in ZIP..."
          if unzip -l backend-deployment.zip | grep -E "(oryx-manifest\.toml|\.deployment)"; then
            echo "ERROR: Oryx artifacts found in ZIP"
            exit 1
          else
            echo "OK: No Oryx artifacts in ZIP"
          fi

      # (Optional) Keep if you want an extra check after the previous step
      - name: Verify 'cors' included in tarball (inside ZIP)
        run: |
          unzip -p backend-deployment.zip node_modules.tar.gz > node_modules.tar.gz
          tar -tzf node_modules.tar.gz cors/package.json >/dev/null 2>&1 || (echo "❌ cors not in node_modules.tar.gz"; exit 1)
          rm -f node_modules.tar.gz

      # Upload the ZIP as a workflow artifact to be consumed by the deploy job
      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: backend-zip
          path: backend-deployment.zip
          if-no-files-found: error

  deploy:
    runs-on: ubuntu-latest
    needs: build
    steps:
      # Download the ZIP to repository root so the deploy step can find it
      - name: Download artifact
        uses: actions/download-artifact@v4
        with:
          name: backend-zip
          path: .

      # Sanity check: ensure the ZIP is present
      - name: Verify downloaded package
        run: |
          ls -la
          test -f backend-deployment.zip || (echo "backend-deployment.zip missing after download" && exit 1)

      # Light warm-up ping to the SCM; not a fix-all, just reduces cold starts
      - name: Warm up SCM
        run: |
          for i in 1 2 3; do
            echo "SCM warmup attempt $i"
            curl -sS -I --max-time 10 https://smarttask-ai-f6gzb6hgcrgngxhq.scm.azurewebsites.net/ || true
            sleep $((5 * i))
          done

      # Extract Kudu (SCM) credentials from the Publish Profile (Bash-only, no Python)
      - name: Extract Kudu credentials from publish profile (Bash-only)
        env:
          PUBLISH_PROFILE_XML: ${{ secrets.AZUREAPPSERVICE_PUBLISHPROFILE_3648A7C097704B079741BF447BA6A912 }}
        run: |
          printf "%s" "$PUBLISH_PROFILE_XML" > publish-profile.xml
          export KUDU_USER="$(perl -0777 -ne 'if(/<publishProfile[^>]*publishMethod="(?:MSDeploy|ZipDeploy)"[^>]*userName="([^"]+)"/s){print $1; exit}' publish-profile.xml)"
          export KUDU_PASS="$(perl -0777 -ne 'if(/<publishProfile[^>]*publishMethod="(?:MSDeploy|ZipDeploy)"[^>]*userPWD="([^"]+)"/s){print $1; exit}' publish-profile.xml)"
          rm -f publish-profile.xml
          {
            echo "KUDU_USER=$KUDU_USER"
            echo "KUDU_PASS=$KUDU_PASS"
          } >> "$GITHUB_ENV"

      # Attempt to clean old Oryx leftovers in wwwroot (safe even if nothing to delete)
      # NOTE: Kudu SCM host is *.scm.azurewebsites.net (no region suffix)
      - name: Clean up Azure App Service (if possible)
        run: |
          echo "Attempting to clean up old deployment artifacts..."
          curl -sS -u "$KUDU_USER:$KUDU_PASS" -X POST "https://smarttask-ai-f6gzb6hgcrgngxhq.scm.azurewebsites.net/api/command" \
            -H "Content-Type: application/json" \
            -d '{"command":"rm -rf /home/site/wwwroot/.deployment /home/site/wwwroot/oryx-manifest.toml /home/site/wwwroot/.npm /home/site/wwwroot/.cache","dir":"/home/site/wwwroot"}' \
            || echo "Cleanup failed, continuing..."

          # Verify cleanup worked
          echo "Verifying cleanup..."
          curl -sS -u "$KUDU_USER:$KUDU_PASS" -X POST "https://smarttask-ai-f6gzb6hgcrgngxhq.scm.azurewebsites.net/api/command" \
            -H "Content-Type: application/json" \
            -d '{"command":"ls -la /home/site/wwwroot","dir":"/home/site/wwwroot"}' \
            || echo "Verification failed"

          echo "Cleanup completed, waiting for Azure to process..."
          sleep 15

      # First deploy attempt (OneDeploy). Allow failure to enable a quick retry.
      - name: Deploy to Azure Web App (attempt 1)
        id: deploy1
        uses: azure/webapps-deploy@v3
        continue-on-error: true
        with:
          app-name: SMARTTASK-AI
          slot-name: production
          publish-profile: ${{ secrets.AZUREAPPSERVICE_PUBLISHPROFILE_3648A7C097704B079741BF447BA6A912 }}
          package: backend-deployment.zip

      # Backoff before retry only if the first attempt failed
      - name: Backoff before retry if needed
        if: steps.deploy1.outcome == 'failure'
        run: |
          echo "First deploy attempt failed; sleeping before retry..."
          sleep 30

      # Second deploy attempt
      - name: Deploy to Azure Web App (attempt 2)
        if: steps.deploy1.outcome == 'failure'
        uses: azure/webapps-deploy@v3
        with:
          app-name: SMARTTASK-AI
          slot-name: production
          publish-profile: ${{ secrets.AZUREAPPSERVICE_PUBLISHPROFILE_3648A7C097704B079741BF447BA6A912 }}
          package: backend-deployment.zip

      # Verify 'cors' exists on server (post-deploy)
      - name: Verify 'cors' exists on server (post-deploy)
        if: success()
        run: |
          echo "Checking for /home/site/wwwroot/node_modules/cors on Kudu..."
          curl -sS -u "$KUDU_USER:$KUDU_PASS" -X POST "https://smarttask-ai-f6gzb6hgcrgngxhq.scm.azurewebsites.net/api/command" \
            -H "Content-Type: application/json" \
            -d '{"command":"ls -lah /home/site/wwwroot/node_modules/cors || ls -lah /home/site/wwwroot/_del_node_modules/cors || ls -lah /node_modules/cors || (echo cors-not-found && exit 2)","dir":"/"}'

      # List node_modules on server (post-deploy)
      - name: List node_modules on server (post-deploy)
        if: success()
        run: |
          echo "Listing /home/site/wwwroot/node_modules (top 200 entries max):"
          curl -sS -u "$KUDU_USER:$KUDU_PASS" -X POST "https://smarttask-ai-f6gzb6hgcrgngxhq.scm.azurewebsites.net/api/command" \
            -H "Content-Type: application/json" \
            -d '{"command":"ls -lah /home/site/wwwroot/node_modules | head -200","dir":"/"}'

      # Basic health check (adjust route if your server exposes a different probe)
      - name: Health check
        run: |
          sleep 30
          curl -f https://smarttask-ai-f6gzb6hgcrgngxhq.israelcentral-01.azurewebsites.net/health || exit 1
