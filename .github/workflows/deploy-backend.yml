name: Deploy Backend (App Service, gated by CI)

on:
  workflow_run:
    workflows: ["CI"]
    types: [completed]
    branches: [main]

permissions:
  contents: read

concurrency:
  group: appsvc-${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  deploy:
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_sha }}

      # --- Debug workflow_run payload ---
      - name: Debug workflow_run payload
        run: |
          echo "=== WORKFLOW_RUN DEBUG INFO ==="
          echo "workflow_run.name=${{ github.event.workflow_run.name }}"
          echo "workflow_run.head_branch=${{ github.event.workflow_run.head_branch }}"
          echo "workflow_run.conclusion=${{ github.event.workflow_run.conclusion }}"
          echo "workflow_run.status=${{ github.event.workflow_run.status }}"
          echo "workflow_run.workflow_id=${{ github.event.workflow_run.workflow_id }}"
          echo "Expected CI workflow name: CI"
          echo "Actual workflow name: ${{ github.event.workflow_run.name }}"
          if [ "${{ github.event.workflow_run.name }}" != "CI" ]; then
            echo "❌ ERROR: Workflow name mismatch!"
            echo "Expected: CI"
            echo "Actual: ${{ github.event.workflow_run.name }}"
            exit 1
          fi
          echo "✅ Workflow name matches correctly"
          echo "Full payload:"
          echo '${{ toJson(github.event.workflow_run) }}'

      # --- Install jq for JSON parsing ---
      - name: Install jq
        run: |
          sudo apt-get update
          sudo apt-get install -y jq
          echo "✅ jq installed"

      # --- Preflight: verify structure and resolve package path ---
      - name: Preflight package path
        id: pkg
        shell: bash
        run: |
          set -e
          echo "Repo root:"
          ls -la
          test -d server || { echo "❌ Missing server/ folder"; exit 1; }
          ls -la server
          test -f server/package.json || { echo "❌ Missing server/package.json"; exit 1; }

          # Prefer a prebuilt bundle if present and non-empty; else use server/
          if [ -d "./server/deploy" ] && [ "$(find ./server/deploy -type f | wc -l)" -gt 0 ]; then
            PKG="./server/deploy"
            echo "Using prebuilt package: $PKG"
          else
            PKG="server"
            echo "Using source package: $PKG"
          fi
          echo "Resolved package path: $PKG"
          echo "pkg=$PKG" >> "$GITHUB_OUTPUT"

      # --- Build server (required for both strategies) ---
      - name: Build server
        working-directory: server
        run: |
          echo "Building server..."
          npm ci
          npm run build
          npm run db:generate
          echo "✅ Build completed"

      # --- Create deployment package if using prebuilt strategy ---
      - name: Create deployment package
        if: steps.pkg.outputs.pkg == './server/deploy'
        working-directory: server
        run: |
          echo "Creating optimized deployment package..."
          
          # Clean previous deployment package
          rm -rf deploy
          
          # Create a clean deployment package
          mkdir -p deploy
          
          # Copy built application
          cp -r dist/* deploy/
          
          # Copy production dependencies
          cp package.json deploy/
          cp package-lock.json deploy/
          
          # Copy Prisma schema and migrations
          cp -r prisma deploy/
          
          # Create production package.json (remove dev dependencies and fix main entry)
          cd deploy
          npm pkg delete devDependencies
          npm pkg delete scripts
          npm pkg set main="index.js"
          npm pkg set scripts.start="node index.js"
          
          # Install only production dependencies
          npm ci --only=production
          
          # Create .deployment file for Azure
          echo "SCM_DO_BUILD_DURING_DEPLOYMENT=false" > .deployment
          echo "WEBSITE_NODE_DEFAULT_VERSION=20" >> .deployment
          echo "WEBSITE_RUN_FROM_PACKAGE=1" >> .deployment
          
          # Create web.config for Azure
          echo '<?xml version="1.0" encoding="utf-8"?>' > web.config
          echo '<configuration>' >> web.config
          echo '  <system.webServer>' >> web.config
          echo '    <handlers>' >> web.config
          echo '      <add name="iisnode" path="index.js" verb="*" modules="iisnode" />' >> web.config
          echo '    </handlers>' >> web.config
          echo '    <rewrite>' >> web.config
          echo '      <rules>' >> web.config
          echo '        <rule name="NodeInspector" patternSyntax="ECMAScript" stopProcessing="true">' >> web.config
          echo '          <match url="^index.js\/debug[\/]?" />' >> web.config
          echo '        </rule>' >> web.config
          echo '        <rule name="StaticContent">' >> web.config
          echo '          <action type="Rewrite" url="index.js" />' >> web.config
          echo '        </rule>' >> web.config
          echo '      </rules>' >> web.config
          echo '    </rewrite>' >> web.config
          echo '    <defaultDocument>' >> web.config
          echo '      <files>' >> web.config
          echo '        <add value="index.js" />' >> web.config
          echo '      </files>' >> web.config
          echo '    </defaultDocument>' >> web.config
          echo '  </system.webServer>' >> web.config
          echo '</configuration>' >> web.config
          
          cd ..
          
          echo "✅ Deployment package created successfully"
          echo "Package contents:"
          ls -la deploy/
          echo "Package size:"
          du -sh deploy



      # --- Create Azure configuration for source package ---
      - name: Create Azure configuration
        if: steps.pkg.outputs.pkg == 'server'
        working-directory: server
        run: |
          echo "Creating Azure configuration files..."
          
          # Create .deployment file for Azure
          echo "SCM_DO_BUILD_DURING_DEPLOYMENT=true" > .deployment
          echo "WEBSITE_NODE_DEFAULT_VERSION=20" >> .deployment
          
          # Create web.config for Azure
          echo '<?xml version="1.0" encoding="utf-8"?>' > web.config
          echo '<configuration>' >> web.config
          echo '  <system.webServer>' >> web.config
          echo '    <handlers>' >> web.config
          echo '      <add name="iisnode" path="dist/index.js" verb="*" modules="iisnode" />' >> web.config
          echo '    </handlers>' >> web.config
          echo '    <rewrite>' >> web.config
          echo '      <rules>' >> web.config
          echo '        <rule name="NodeInspector" patternSyntax="ECMAScript" stopProcessing="true">' >> web.config
          echo '          <match url="^dist\/index.js\/debug[\/]?" />' >> web.config
          echo '        </rule>' >> web.config
          echo '        <rule name="StaticContent">' >> web.config
          echo '          <action type="Rewrite" url="dist/index.js" />' >> web.config
          echo '        </rule>' >> web.config
          echo '      </rules>' >> web.config
          echo '    </rewrite>' >> web.config
          echo '    <defaultDocument>' >> web.config
          echo '      <files>' >> web.config
          echo '        <add value="dist/index.js" />' >> web.config
          echo '      </files>' >> web.config
          echo '    </defaultDocument>' >> web.config
          echo '  </system.webServer>' >> web.config
          echo '</configuration>' >> web.config
          
          echo "✅ Azure configuration files created"
          echo "Files created:"
          ls -la .deployment web.config

      # --- Final package validation ---
      - name: Final package validation
        run: |
          echo "=== FINAL PACKAGE VALIDATION ==="
          echo "Package path: ${{ steps.pkg.outputs.pkg }}"
          echo "Build mode: ${{ steps.pkg.outputs.pkg == 'server' && 'source' || 'prebuilt' }}"
          
          if [ -d "${{ steps.pkg.outputs.pkg }}" ]; then
            echo "Package contents:"
            ls -la "${{ steps.pkg.outputs.pkg }}"
            
            if [ -f "${{ steps.pkg.outputs.pkg }}/package.json" ]; then
              echo "Package.json contents:"
              cat "${{ steps.pkg.outputs.pkg }}/package.json"
            fi
            
            echo "Package size:"
            du -sh "${{ steps.pkg.outputs.pkg }}"
          else
            echo "❌ ERROR: Package directory does not exist"
            exit 1
          fi
          
          echo "✅ Package validation completed"

      # --- Parse publish profile for Kudu basic auth (to inspect status) ---
      - name: Parse publish profile for Kudu auth
        id: kudu_auth
        shell: bash
        run: |
          set -e
          echo "${{ secrets.AZUREAPPSERVICE_PUBLISHPROFILE_3648A7C097704B079741BF447BA6A912 }}" > pubprofile.xml
          USER=$(sed -n 's/.*publishMethod="MSDeploy".*userName="\([^"]*\)".*/\1/p' pubprofile.xml | head -1)
          PASS=$(sed -n 's/.*publishMethod="MSDeploy".*userPWD="\([^"]*\)".*/\1/p' pubprofile.xml | head -1)
          if [ -z "$USER" ] || [ -z "$PASS" ]; then
            echo "❌ Could not extract MSDeploy creds from publish profile"
            exit 1
          fi
          AUTH=$(printf "%s:%s" "$USER" "$PASS" | base64)
          echo "auth=$AUTH" >> "$GITHUB_OUTPUT"
          echo "✅ Kudu auth extracted"

      # --- Inspect Kudu and wait until idle to avoid 409 conflicts ---
      - name: Wait for Kudu to be idle
        shell: bash
        env:
          AUTH: ${{ steps.kudu_auth.outputs.auth }}
        run: |
          set -e
          BASE="https://smarttask-ai-f6gzb6hgcrgngxhq.israelcentral-01.scm.azurewebsites.net"
          echo "Checking Kudu deployment status..."
          
          for delay in 0 10 20 40 60 90; do
            [ $delay -gt 0 ] && echo "Kudu busy. Sleeping ${delay}s..." && sleep $delay
            
            res=$(curl -s -H "Authorization: Basic $AUTH" "$BASE/api/deployments/latest" || true)
            end=$(echo "$res" | jq -r '.end_time' 2>/dev/null || echo null)
            prog=$(echo "$res" | jq -r '.progress' 2>/dev/null || echo null)
            status=$(echo "$res" | jq -r '.status_text' 2>/dev/null || echo null)
            
            echo "Latest deployment: end_time=$end, progress=$prog, status=$status"
            
            if [ "$end" != "null" ] && [ "$prog" = "null" ]; then
              echo "✅ Kudu idle - proceeding with deployment"
              exit 0
            fi
          done
          
          echo "::warning::Kudu may still be busy; proceeding anyway."

      # --- First deploy attempt (no slot-name!) ---
      - name: Deploy to Azure Web App (attempt 1)
        id: deploy1
        uses: azure/webapps-deploy@v3
        continue-on-error: true
        with:
          app-name: SMARTTASK-AI
          package: ${{ steps.pkg.outputs.pkg }}
          publish-profile: ${{ secrets.AZUREAPPSERVICE_PUBLISHPROFILE_3648A7C097704B079741BF447BA6A912 }}

      # --- If first attempt failed, wait again, then retry once ---
      - name: Wait again if first attempt failed
        if: ${{ steps.deploy1.outcome == 'failure' }}
        shell: bash
        env:
          AUTH: ${{ steps.kudu_auth.outputs.auth }}
        run: |
          set -e
          BASE="https://smarttask-ai-f6gzb6hgcrgngxhq.israelcentral-01.scm.azurewebsites.net"
          echo "First deployment failed. Waiting for Kudu to be idle before retry..."
          
          for delay in 20 40 60 90; do
            echo "Retry backoff ${delay}s..."
            sleep $delay
            
            res=$(curl -s -H "Authorization: Basic $AUTH" "$BASE/api/deployments/latest" || true)
            end=$(echo "$res" | jq -r '.end_time' 2>/dev/null || echo null)
            prog=$(echo "$res" | jq -r '.progress' 2>/dev/null || echo null)
            status=$(echo "$res" | jq -r '.status_text' 2>/dev/null || echo null)
            
            echo "Latest deployment: end_time=$end, progress=$prog, status=$status"
            
            if [ "$end" != "null" ] && [ "$prog" = "null" ]; then
              echo "✅ Kudu idle - proceeding with retry"
              break
            fi
          done

      - name: Deploy to Azure Web App (attempt 2)
        if: ${{ steps.deploy1.outcome == 'failure' }}
        uses: azure/webapps-deploy@v3
        with:
          app-name: SMARTTASK-AI
          package: ${{ steps.pkg.outputs.pkg }}
          publish-profile: ${{ secrets.AZUREAPPSERVICE_PUBLISHPROFILE_3648A7C097704B079741BF447BA6A912 }}

      # --- Prisma migrations after successful deployment ---
      - name: Run Prisma migrations
        if: ${{ success() }}
        working-directory: ./server
        run: |
          echo "=== PRISMA MIGRATIONS ==="
          echo "Running Prisma migrations..."
          echo "Database URL: ${{ secrets.PRODUCTION_DATABASE_URL }}"
          
          # Install dependencies if needed
          if [ ! -d "node_modules" ]; then
            npm ci
          fi
          
          npm run db:migrate:deploy
          echo "✅ Prisma migrations completed"
        env:
          DATABASE_URL: ${{ secrets.PRODUCTION_DATABASE_URL }}

      # --- Health check after successful deployment ---
      - name: Health check
        if: ${{ success() }}
        run: |
          echo "=== HEALTH CHECK ==="
          echo "Waiting for app to start..."
          sleep 30
          
          echo "Attempting health check..."
          # Try to hit the health endpoint
          curl -f https://smarttask-ai-f6gzb6hgcrgngxhq.israelcentral-01.azurewebsites.net/health || echo "Health check failed, but deployment may still be successful"
          echo "Health check completed"

      # --- Success notification ---
      - name: Notify deployment success
        if: ${{ success() }}
        run: |
          echo "✅ Successfully deployed to production"
          echo "Package used: ${{ steps.pkg.outputs.pkg }}"
          echo "Build mode: ${{ steps.pkg.outputs.pkg == 'server' && 'source' || 'prebuilt' }}"
          echo "Slot used: default (production)"
          echo "Deployment completed successfully!"

      # --- On failure, upload diagnostics ---
      - name: Upload diagnostics on failure
        if: ${{ failure() }}
        uses: actions/upload-artifact@v4
        with:
          name: backend-deploy-diagnostics-${{ github.run_id }}
          path: |
            server/package.json
            server/package-lock.json
            server/
            pubprofile.xml
          retention-days: 30

      # --- Failure diagnostics ---
      - name: Failure diagnostics
        if: ${{ failure() }}
        shell: bash
        env:
          AUTH: ${{ steps.kudu_auth.outputs.auth }}
        run: |
          echo "=== FAILURE DIAGNOSTICS ==="
          
          # 1. Package path used
          echo "1. Package path used: ${{ steps.pkg.outputs.pkg }}"
          
          # 2. Build mode
          echo "2. Build mode: ${{ steps.pkg.outputs.pkg == 'server' && 'source' || 'prebuilt' }}"
          
          # 3. Slot information
          echo "3. Slot used: default (production) - no slot-name specified"
          
          # 4. Package contents (if available)
          if [ -d "${{ steps.pkg.outputs.pkg }}" ]; then
            echo "4. Package contents:"
            ls -la "${{ steps.pkg.outputs.pkg }}"
            
            if [ -f "${{ steps.pkg.outputs.pkg }}/package.json" ]; then
              echo "5. Package.json contents:"
              cat "${{ steps.pkg.outputs.pkg }}/package.json"
            fi
          fi
          
          # 5. Kudu deployment status
          echo "6. Kudu deployment status:"
          BASE="https://smarttask-ai-f6gzb6hgcrgngxhq.israelcentral-01.scm.azurewebsites.net"
          res=$(curl -s -H "Authorization: Basic $AUTH" "$BASE/api/deployments/latest" || echo "Failed to fetch Kudu status")
          echo "$res" | jq . 2>/dev/null || echo "$res"
          
          # 6. Recent deployments
          echo "7. Recent deployments:"
          res=$(curl -s -H "Authorization: Basic $AUTH" "$BASE/api/deployments" || echo "Failed to fetch recent deployments")
          echo "$res" | jq '.[0:3]' 2>/dev/null || echo "$res"
          
          echo "❌ Deployment failed - see diagnostics above for troubleshooting"
